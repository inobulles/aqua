# This Source Form is subject to the terms of the AQUA Software License, v. 1.0.
# Copyright (c) 2025 Aymeric Wibo

import os
from datetime import datetime
year = datetime.now().year

PACKED = "__attribute__((packed))"

# WebGPU commands in the spec which aren't yet implemented by wgpu-native.

WGPU_BLACKLIST = (
	"wgpuAdapterRequestAdapterInfo",
	"wgpuInstanceHasWGSLLanguageFeature",
	"wgpuSurfaceSetLabel",
)

with open(".bob/prefix/include/webgpu-headers/webgpu.h") as f:
	*lines, = map(str.rstrip, f.readlines())

with open(".bob/prefix/include/wgpu.h") as f:
	lines += [*map(str.rstrip, f.readlines())]

def wgpu_type_to_kos(t: str):
	KNOWN = {
		"void": "KOS_TYPE_VOID",
		"size_t": "KOS_TYPE_U32",
		"int32_t": "KOS_TYPE_I32",
		"uint32_t": "KOS_TYPE_U32",
		"uint64_t": "KOS_TYPE_U64",
		"float": "KOS_TYPE_F32",
		"WGPUBool": "KOS_TYPE_BOOL",
		"char const *": "KOS_TYPE_BUF",
		"void const *": "KOS_TYPE_OPAQUE_PTR",
		"void *": "KOS_TYPE_OPAQUE_PTR",
	}

	if t in KNOWN:
		return KNOWN[t]

	# TODO Since some of these structs can have pointers to other stuff in them and thus can't be serialized/deserialized (which a buf normally has to be), should this not be a ptr instead?

	if t[-1] == "*":
		return "KOS_TYPE_BUF"

	if t in enums:
		return "KOS_TYPE_U32"

	return "KOS_TYPE_OPAQUE_PTR"

def kos_type_to_union(t: str):
	if t == "KOS_TYPE_BOOL":
		return "b"

	return t.removeprefix("KOS_TYPE_").lower()

enums = set()
fns = "static kos_fn_t const FNS[] = {\n"
call_handlers = ""
fn_id = 0
cmds = "" # REMME
impls = ""

c_types = ""
c_wrappers = ""

for line in lines:
	# Parse function declaration.

	if line.startswith("#include \""):
		continue

	if line.endswith(" WGPU_ENUM_ATTRIBUTE;"):
		enums.add(line.split()[-2])
		continue

	if not line.startswith("WGPU_EXPORT "):
		c_types += line + "\n"
		continue

	type_and_name, params = line.split('(')
	_, *ret_type, name = type_and_name.split()
	ret_type = ' '.join(ret_type)

	if name in WGPU_BLACKLIST:
		continue

	raw_params = params.split(')')[0]
	params = raw_params.split(", ")
	param_types = []
	param_names = []

	for arg in params:
		*t, arg_name = arg.split()
		param_types.append(' '.join(t).removeprefix("WGPU_NULLABLE "))
		param_names.append(arg_name)

	# Generate function struct.

	fns += f"""\t{{
		.name = "{name}",
		.ret_type = {wgpu_type_to_kos(ret_type)},
		.param_count = {len(param_names)},
		.params = (kos_param_t[]) {{\n"""

	for t, n in zip(param_types, param_names):
		fns += f"""\t\t\t{{
				.type = {wgpu_type_to_kos(t)},
				.name = "{n}",
			}},\n"""

	fns += "\t\t},\n\t},\n"

	# Generate args parser for call handler.

	parser = ""

	for i, p in enumerate(param_names):
		t = param_types[i]
		kos_t = wgpu_type_to_kos(t)

		if t in ("WGPUSurfaceCapabilities", "WGPUAdapterInfo"):
			parser += f"\t\t{t} const {p} = *({t}*) args[{i}].opaque_ptr;\n"

		elif kos_t == "KOS_TYPE_BUF":
			parser += f"\t\t{t} const {p} = args[{i}].buf.ptr;\n"
			parser += f"\t\tassert(args[{i}].buf.size == sizeof *{p});\n"

		elif kos_t == "KOS_TYPE_OPAQUE_PTR":
			parser += f"\t\t{t} const {p} = args[{i}].opaque_ptr;\n"

		else:
			union = kos_type_to_union(kos_t)
			parser += f"\t\t{t} const {p} = args[{i}].{union};\n"

	# Generate return code.

	kos_ret_type = wgpu_type_to_kos(ret_type)

	if kos_ret_type == "KOS_TYPE_VOID":
		ret = ""

	elif kos_ret_type == "KOS_TYPE_OPAQUE_PTR":
		ret = f"notif.call_ret.ret.opaque_ptr = (void*) "

	else:
		union = kos_type_to_union(kos_ret_type)
		ret = f"notif.call_ret.ret.{union} = "

	# Generate actual call handler.

	call_handlers += f"""\tcase {fn_id}: {{
{parser}\t\t{ret}{name}({", ".join(param_names)});
		break;
	}}
"""

	fn_id += 1

fns += "};\n"

# Write out functions.

with open("fns.h", "w") as f:
	f.write(f"""// This Source Form is subject to the terms of the AQUA Software License, v. 1.0.
// Copyright (c) {year} Aymeric Wibo

// This file is automatically generated by 'vdev/wgpu/gen.py'.
// If you need to update this, read the 'vdev/wgpu/README.md' document.

#include "../../kos/vdev.h"

{fns}""")

# Inject generated call handlers into device source.

with open("main.c") as f:
	src = f.read().split("\n")

begin = src.index("\t// CALL_HANDLERS:BEGIN")
end = src.index("\t// CALL_HANDLERS:END")

assert begin != -1 and end != -1
assert begin < end

src = "\n".join(src[:begin + 1] + call_handlers.strip("\n").split("\n") + src[end:])

with open("main.c", "w") as f:
	f.write(src)

# Compile device as a sanity check.

os.system("bob build")

exit()

# C library source

lib_out = f"""// This Source Form is subject to the terms of the AQUA Software License, v. 1.0.
// Copyright (c) {year} Aymeric Wibo

// this file is automatically generated by 'aqua-devices/aquabsd.black/wgpu/gen.py'
// if you need to update this, read the 'aqua-devices/aquabsd.black/wgpu/README.md' document

#pragma once

#include <root.h>

#include "wgpu_types.h"

static device_t wgpu_device = NO_DEVICE;

AQUA_C_FN int wgpu_init(void) {{
	wgpu_device = query_device("aquabsd.black.wgpu");

	if (wgpu_device == NO_DEVICE) {{
		return ERR_NO_DEVICE;
	}}

	return SUCCESS;
}}

#if defined(AQUABSD_ALPS_WIN) || defined(AQUABSD_BLACK_WIN)
AQUA_C_FN WGPUSurface wgpu_surface_from_win(WGPUInstance instance, win_t* win) {{
	struct {{
		WGPUInstance instance;
		void* win;
	}} {PACKED} const args = {{
		.instance = instance,
		.win = (void*) win->internal_win,
	}};

	return (WGPUSurface) send_device(wgpu_device, {CMD_SURFACE_FROM_WIN}, (void*) &args);
}}
#endif

#if defined(AQUABSD_BLACK_WM)
AQUA_C_FN WGPUDevice wgpu_device_from_wm(WGPUInstance instance, wm_t* wm) {{
	struct {{
		WGPUInstance instance;
		void* wm;
	}} {PACKED} const args = {{
		.instance = instance,
		.wm = (void*) wm->internal_wm,
	}};

	return (WGPUDevice) send_device(wgpu_device, {CMD_DEVICE_FROM_WM}, (void*) &args);
}}

AQUA_C_FN WGPUTexture wgpu_device_texture_from_wm(WGPUDevice device, wm_t* wm) {{
	struct {{
		WGPUDevice device;
		void* wm;
	}} {PACKED} const args = {{
		.device = device,
		.wm = (void*) wm->internal_wm,
	}};

	return (WGPUTexture) send_device(wgpu_device, {CMD_DEVICE_TEXTURE_FROM_WM}, (void*) &args);
}}
#endif
{c_wrappers}"""

if not os.path.exists("c-lib"):
	os.mkdir("c-lib")

with open("c-lib/wgpu.h", "w") as f:
	f.write(lib_out)

with open("c-lib/wgpu_types.h", "w") as f:
	f.write(c_types)
