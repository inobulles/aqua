// This Source Form is subject to the terms of the AQUA Software License,
// v. 1.0. Copyright (c) 2025 Aymeric Wibo

#include "../../kos/vdev.h"

#include <assert.h>
#include <stdlib.h>

#include ".bob/prefix/include/webgpu-headers/webgpu.h"

#define SPEC "aquabsd.black.wgpu"
#define VERS 0
#define VDRIVER_HUMAN "WebGPU driver"

vdriver_t VDRIVER;
static vid_t only_vid;

static void probe(void) {
	assert(VDRIVER.notif_cb != NULL);

	// TODO Report all the GPUs on the system?

	only_vid = VDRIVER.vdev_id_lo;

	kos_notif_t const notif = {
		.kind = KOS_NOTIF_ATTACH,
		.attach.vdev = {
			.kind = KOS_VDEV_KIND_LOCAL,
			.spec = SPEC,
			.vers = VERS,
			.human = "WebGPU GPU", // TODO Should we get the actual GPU's name here?
			.vdriver_human = VDRIVER_HUMAN,
		},
	};

	VDRIVER.notif_cb(&notif, VDRIVER.notif_data);
}

#include "fns.h"

static void conn(kos_cookie_t cookie, vid_t vid, uint64_t conn_id) {
	assert(VDRIVER.notif_cb != NULL);

	if (vid != only_vid) {
		kos_notif_t const notif = {
			.kind = KOS_NOTIF_CONN_FAIL,
		};

		VDRIVER.notif_cb(&notif, VDRIVER.notif_data);
		return;
	}

	kos_notif_t const notif = {
		.kind = KOS_NOTIF_CONN,
		.cookie = cookie,
		.conn = {
			.conn_id = conn_id,
			.fn_count = sizeof(FNS) / sizeof(*FNS),
			.fns = FNS,
		},
	};

	VDRIVER.notif_cb(&notif, VDRIVER.notif_data);
}

static void call(kos_cookie_t cookie, uint64_t conn_id, uint64_t fn_id, kos_val_t const* args) {
	assert(VDRIVER.notif_cb != NULL);

	(void) conn_id;

	kos_notif_t notif = {
		.kind = KOS_NOTIF_CALL_RET,
		.cookie = cookie,
	};

	// This code is automatically generated by 'vdev/wgpu/gen.py'
	// If you need to update this, read the 'vdev/wgpu/README.md' document.

	switch (fn_id) {
	// CALL_HANDLERS:BEGIN
	case 0: {
		WGPUInstanceDescriptor const* const descriptor = args[0].buf.ptr;
		assert(args[0].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuCreateInstance(descriptor);
		break;
	}
	case 1: {
		WGPUDevice const device = args[0].opaque_ptr;
		char const* const procName = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *procName);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuGetProcAddress(device, procName);
		break;
	}
	case 2: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		WGPUFeatureName* const features = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *features);
		notif.call_ret.ret.u32 = wgpuAdapterEnumerateFeatures(adapter, features);
		break;
	}
	case 3: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		WGPUAdapterInfo* const info = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *info);
		wgpuAdapterGetInfo(adapter, info);
		break;
	}
	case 4: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		WGPUSupportedLimits* const limits = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *limits);
		notif.call_ret.ret.b = wgpuAdapterGetLimits(adapter, limits);
		break;
	}
	case 5: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		WGPUFeatureName const feature = args[1].u32;
		notif.call_ret.ret.b = wgpuAdapterHasFeature(adapter, feature);
		break;
	}
	case 6: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		WGPUDeviceDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		WGPUAdapterRequestDeviceCallback const callback = args[2].opaque_ptr;
		void* const userdata = args[3].opaque_ptr;
		wgpuAdapterRequestDevice(adapter, descriptor, callback, userdata);
		break;
	}
	case 7: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		wgpuAdapterReference(adapter);
		break;
	}
	case 8: {
		WGPUAdapter const adapter = args[0].opaque_ptr;
		wgpuAdapterRelease(adapter);
		break;
	}
	case 9: {
		WGPUAdapterInfo const adapterInfo = *(WGPUAdapterInfo*) args[0].opaque_ptr;
		wgpuAdapterInfoFreeMembers(adapterInfo);
		break;
	}
	case 10: {
		WGPUBindGroup const bindGroup = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuBindGroupSetLabel(bindGroup, label);
		break;
	}
	case 11: {
		WGPUBindGroup const bindGroup = args[0].opaque_ptr;
		wgpuBindGroupReference(bindGroup);
		break;
	}
	case 12: {
		WGPUBindGroup const bindGroup = args[0].opaque_ptr;
		wgpuBindGroupRelease(bindGroup);
		break;
	}
	case 13: {
		WGPUBindGroupLayout const bindGroupLayout = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuBindGroupLayoutSetLabel(bindGroupLayout, label);
		break;
	}
	case 14: {
		WGPUBindGroupLayout const bindGroupLayout = args[0].opaque_ptr;
		wgpuBindGroupLayoutReference(bindGroupLayout);
		break;
	}
	case 15: {
		WGPUBindGroupLayout const bindGroupLayout = args[0].opaque_ptr;
		wgpuBindGroupLayoutRelease(bindGroupLayout);
		break;
	}
	case 16: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		wgpuBufferDestroy(buffer);
		break;
	}
	case 17: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		size_t const offset = args[1].u32;
		size_t const size = args[2].u32;
		notif.call_ret.ret.opaque_ptr = (void*) wgpuBufferGetConstMappedRange(buffer, offset, size);
		break;
	}
	case 18: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuBufferGetMapState(buffer);
		break;
	}
	case 19: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		size_t const offset = args[1].u32;
		size_t const size = args[2].u32;
		notif.call_ret.ret.opaque_ptr = (void*) wgpuBufferGetMappedRange(buffer, offset, size);
		break;
	}
	case 20: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		notif.call_ret.ret.u64 = wgpuBufferGetSize(buffer);
		break;
	}
	case 21: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuBufferGetUsage(buffer);
		break;
	}
	case 22: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		WGPUMapModeFlags const mode = args[1].u32;
		size_t const offset = args[2].u32;
		size_t const size = args[3].u32;
		WGPUBufferMapAsyncCallback const callback = args[4].opaque_ptr;
		void* const userdata = args[5].opaque_ptr;
		wgpuBufferMapAsync(buffer, mode, offset, size, callback, userdata);
		break;
	}
	case 23: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuBufferSetLabel(buffer, label);
		break;
	}
	case 24: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		wgpuBufferUnmap(buffer);
		break;
	}
	case 25: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		wgpuBufferReference(buffer);
		break;
	}
	case 26: {
		WGPUBuffer const buffer = args[0].opaque_ptr;
		wgpuBufferRelease(buffer);
		break;
	}
	case 27: {
		WGPUCommandBuffer const commandBuffer = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuCommandBufferSetLabel(commandBuffer, label);
		break;
	}
	case 28: {
		WGPUCommandBuffer const commandBuffer = args[0].opaque_ptr;
		wgpuCommandBufferReference(commandBuffer);
		break;
	}
	case 29: {
		WGPUCommandBuffer const commandBuffer = args[0].opaque_ptr;
		wgpuCommandBufferRelease(commandBuffer);
		break;
	}
	case 30: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUComputePassDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuCommandEncoderBeginComputePass(commandEncoder, descriptor);
		break;
	}
	case 31: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPURenderPassDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuCommandEncoderBeginRenderPass(commandEncoder, descriptor);
		break;
	}
	case 32: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUBuffer const buffer = args[1].opaque_ptr;
		uint64_t const offset = args[2].u64;
		uint64_t const size = args[3].u64;
		wgpuCommandEncoderClearBuffer(commandEncoder, buffer, offset, size);
		break;
	}
	case 33: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUBuffer const source = args[1].opaque_ptr;
		uint64_t const sourceOffset = args[2].u64;
		WGPUBuffer const destination = args[3].opaque_ptr;
		uint64_t const destinationOffset = args[4].u64;
		uint64_t const size = args[5].u64;
		wgpuCommandEncoderCopyBufferToBuffer(commandEncoder, source, sourceOffset, destination, destinationOffset, size);
		break;
	}
	case 34: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUImageCopyBuffer const* const source = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *source);
		WGPUImageCopyTexture const* const destination = args[2].buf.ptr;
		assert(args[2].buf.size == sizeof *destination);
		WGPUExtent3D const* const copySize = args[3].buf.ptr;
		assert(args[3].buf.size == sizeof *copySize);
		wgpuCommandEncoderCopyBufferToTexture(commandEncoder, source, destination, copySize);
		break;
	}
	case 35: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUImageCopyTexture const* const source = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *source);
		WGPUImageCopyBuffer const* const destination = args[2].buf.ptr;
		assert(args[2].buf.size == sizeof *destination);
		WGPUExtent3D const* const copySize = args[3].buf.ptr;
		assert(args[3].buf.size == sizeof *copySize);
		wgpuCommandEncoderCopyTextureToBuffer(commandEncoder, source, destination, copySize);
		break;
	}
	case 36: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUImageCopyTexture const* const source = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *source);
		WGPUImageCopyTexture const* const destination = args[2].buf.ptr;
		assert(args[2].buf.size == sizeof *destination);
		WGPUExtent3D const* const copySize = args[3].buf.ptr;
		assert(args[3].buf.size == sizeof *copySize);
		wgpuCommandEncoderCopyTextureToTexture(commandEncoder, source, destination, copySize);
		break;
	}
	case 37: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUCommandBufferDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuCommandEncoderFinish(commandEncoder, descriptor);
		break;
	}
	case 38: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		char const* const markerLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *markerLabel);
		wgpuCommandEncoderInsertDebugMarker(commandEncoder, markerLabel);
		break;
	}
	case 39: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		wgpuCommandEncoderPopDebugGroup(commandEncoder);
		break;
	}
	case 40: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		char const* const groupLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *groupLabel);
		wgpuCommandEncoderPushDebugGroup(commandEncoder, groupLabel);
		break;
	}
	case 41: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUQuerySet const querySet = args[1].opaque_ptr;
		uint32_t const firstQuery = args[2].u32;
		uint32_t const queryCount = args[3].u32;
		WGPUBuffer const destination = args[4].opaque_ptr;
		uint64_t const destinationOffset = args[5].u64;
		wgpuCommandEncoderResolveQuerySet(commandEncoder, querySet, firstQuery, queryCount, destination, destinationOffset);
		break;
	}
	case 42: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuCommandEncoderSetLabel(commandEncoder, label);
		break;
	}
	case 43: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		WGPUQuerySet const querySet = args[1].opaque_ptr;
		uint32_t const queryIndex = args[2].u32;
		wgpuCommandEncoderWriteTimestamp(commandEncoder, querySet, queryIndex);
		break;
	}
	case 44: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		wgpuCommandEncoderReference(commandEncoder);
		break;
	}
	case 45: {
		WGPUCommandEncoder const commandEncoder = args[0].opaque_ptr;
		wgpuCommandEncoderRelease(commandEncoder);
		break;
	}
	case 46: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		uint32_t const workgroupCountX = args[1].u32;
		uint32_t const workgroupCountY = args[2].u32;
		uint32_t const workgroupCountZ = args[3].u32;
		wgpuComputePassEncoderDispatchWorkgroups(computePassEncoder, workgroupCountX, workgroupCountY, workgroupCountZ);
		break;
	}
	case 47: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		WGPUBuffer const indirectBuffer = args[1].opaque_ptr;
		uint64_t const indirectOffset = args[2].u64;
		wgpuComputePassEncoderDispatchWorkgroupsIndirect(computePassEncoder, indirectBuffer, indirectOffset);
		break;
	}
	case 48: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		wgpuComputePassEncoderEnd(computePassEncoder);
		break;
	}
	case 49: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		char const* const markerLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *markerLabel);
		wgpuComputePassEncoderInsertDebugMarker(computePassEncoder, markerLabel);
		break;
	}
	case 50: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		wgpuComputePassEncoderPopDebugGroup(computePassEncoder);
		break;
	}
	case 51: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		char const* const groupLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *groupLabel);
		wgpuComputePassEncoderPushDebugGroup(computePassEncoder, groupLabel);
		break;
	}
	case 52: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		uint32_t const groupIndex = args[1].u32;
		WGPUBindGroup const group = args[2].opaque_ptr;
		size_t const dynamicOffsetCount = args[3].u32;
		uint32_t const* const dynamicOffsets = args[4].buf.ptr;
		assert(args[4].buf.size == sizeof *dynamicOffsets);
		wgpuComputePassEncoderSetBindGroup(computePassEncoder, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
		break;
	}
	case 53: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuComputePassEncoderSetLabel(computePassEncoder, label);
		break;
	}
	case 54: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		WGPUComputePipeline const pipeline = args[1].opaque_ptr;
		wgpuComputePassEncoderSetPipeline(computePassEncoder, pipeline);
		break;
	}
	case 55: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		wgpuComputePassEncoderReference(computePassEncoder);
		break;
	}
	case 56: {
		WGPUComputePassEncoder const computePassEncoder = args[0].opaque_ptr;
		wgpuComputePassEncoderRelease(computePassEncoder);
		break;
	}
	case 57: {
		WGPUComputePipeline const computePipeline = args[0].opaque_ptr;
		uint32_t const groupIndex = args[1].u32;
		notif.call_ret.ret.opaque_ptr = (void*) wgpuComputePipelineGetBindGroupLayout(computePipeline, groupIndex);
		break;
	}
	case 58: {
		WGPUComputePipeline const computePipeline = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuComputePipelineSetLabel(computePipeline, label);
		break;
	}
	case 59: {
		WGPUComputePipeline const computePipeline = args[0].opaque_ptr;
		wgpuComputePipelineReference(computePipeline);
		break;
	}
	case 60: {
		WGPUComputePipeline const computePipeline = args[0].opaque_ptr;
		wgpuComputePipelineRelease(computePipeline);
		break;
	}
	case 61: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUBindGroupDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateBindGroup(device, descriptor);
		break;
	}
	case 62: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUBindGroupLayoutDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateBindGroupLayout(device, descriptor);
		break;
	}
	case 63: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUBufferDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateBuffer(device, descriptor);
		break;
	}
	case 64: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUCommandEncoderDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateCommandEncoder(device, descriptor);
		break;
	}
	case 65: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUComputePipelineDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateComputePipeline(device, descriptor);
		break;
	}
	case 66: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUComputePipelineDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		WGPUDeviceCreateComputePipelineAsyncCallback const callback = args[2].opaque_ptr;
		void* const userdata = args[3].opaque_ptr;
		wgpuDeviceCreateComputePipelineAsync(device, descriptor, callback, userdata);
		break;
	}
	case 67: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUPipelineLayoutDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreatePipelineLayout(device, descriptor);
		break;
	}
	case 68: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUQuerySetDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateQuerySet(device, descriptor);
		break;
	}
	case 69: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPURenderBundleEncoderDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateRenderBundleEncoder(device, descriptor);
		break;
	}
	case 70: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPURenderPipelineDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateRenderPipeline(device, descriptor);
		break;
	}
	case 71: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPURenderPipelineDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		WGPUDeviceCreateRenderPipelineAsyncCallback const callback = args[2].opaque_ptr;
		void* const userdata = args[3].opaque_ptr;
		wgpuDeviceCreateRenderPipelineAsync(device, descriptor, callback, userdata);
		break;
	}
	case 72: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUSamplerDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateSampler(device, descriptor);
		break;
	}
	case 73: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUShaderModuleDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateShaderModule(device, descriptor);
		break;
	}
	case 74: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUTextureDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceCreateTexture(device, descriptor);
		break;
	}
	case 75: {
		WGPUDevice const device = args[0].opaque_ptr;
		wgpuDeviceDestroy(device);
		break;
	}
	case 76: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUFeatureName* const features = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *features);
		notif.call_ret.ret.u32 = wgpuDeviceEnumerateFeatures(device, features);
		break;
	}
	case 77: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUSupportedLimits* const limits = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *limits);
		notif.call_ret.ret.b = wgpuDeviceGetLimits(device, limits);
		break;
	}
	case 78: {
		WGPUDevice const device = args[0].opaque_ptr;
		notif.call_ret.ret.opaque_ptr = (void*) wgpuDeviceGetQueue(device);
		break;
	}
	case 79: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUFeatureName const feature = args[1].u32;
		notif.call_ret.ret.b = wgpuDeviceHasFeature(device, feature);
		break;
	}
	case 80: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUErrorCallback const callback = args[1].opaque_ptr;
		void* const userdata = args[2].opaque_ptr;
		wgpuDevicePopErrorScope(device, callback, userdata);
		break;
	}
	case 81: {
		WGPUDevice const device = args[0].opaque_ptr;
		WGPUErrorFilter const filter = args[1].u32;
		wgpuDevicePushErrorScope(device, filter);
		break;
	}
	case 82: {
		WGPUDevice const device = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuDeviceSetLabel(device, label);
		break;
	}
	case 83: {
		WGPUDevice const device = args[0].opaque_ptr;
		wgpuDeviceReference(device);
		break;
	}
	case 84: {
		WGPUDevice const device = args[0].opaque_ptr;
		wgpuDeviceRelease(device);
		break;
	}
	case 85: {
		WGPUInstance const instance = args[0].opaque_ptr;
		WGPUSurfaceDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuInstanceCreateSurface(instance, descriptor);
		break;
	}
	case 86: {
		WGPUInstance const instance = args[0].opaque_ptr;
		wgpuInstanceProcessEvents(instance);
		break;
	}
	case 87: {
		WGPUInstance const instance = args[0].opaque_ptr;
		WGPURequestAdapterOptions const* const options = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *options);
		WGPUInstanceRequestAdapterCallback const callback = args[2].opaque_ptr;
		void* const userdata = args[3].opaque_ptr;
		wgpuInstanceRequestAdapter(instance, options, callback, userdata);
		break;
	}
	case 88: {
		WGPUInstance const instance = args[0].opaque_ptr;
		wgpuInstanceReference(instance);
		break;
	}
	case 89: {
		WGPUInstance const instance = args[0].opaque_ptr;
		wgpuInstanceRelease(instance);
		break;
	}
	case 90: {
		WGPUPipelineLayout const pipelineLayout = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuPipelineLayoutSetLabel(pipelineLayout, label);
		break;
	}
	case 91: {
		WGPUPipelineLayout const pipelineLayout = args[0].opaque_ptr;
		wgpuPipelineLayoutReference(pipelineLayout);
		break;
	}
	case 92: {
		WGPUPipelineLayout const pipelineLayout = args[0].opaque_ptr;
		wgpuPipelineLayoutRelease(pipelineLayout);
		break;
	}
	case 93: {
		WGPUQuerySet const querySet = args[0].opaque_ptr;
		wgpuQuerySetDestroy(querySet);
		break;
	}
	case 94: {
		WGPUQuerySet const querySet = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuQuerySetGetCount(querySet);
		break;
	}
	case 95: {
		WGPUQuerySet const querySet = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuQuerySetGetType(querySet);
		break;
	}
	case 96: {
		WGPUQuerySet const querySet = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuQuerySetSetLabel(querySet, label);
		break;
	}
	case 97: {
		WGPUQuerySet const querySet = args[0].opaque_ptr;
		wgpuQuerySetReference(querySet);
		break;
	}
	case 98: {
		WGPUQuerySet const querySet = args[0].opaque_ptr;
		wgpuQuerySetRelease(querySet);
		break;
	}
	case 99: {
		WGPUQueue const queue = args[0].opaque_ptr;
		WGPUQueueOnSubmittedWorkDoneCallback const callback = args[1].opaque_ptr;
		void* const userdata = args[2].opaque_ptr;
		wgpuQueueOnSubmittedWorkDone(queue, callback, userdata);
		break;
	}
	case 100: {
		WGPUQueue const queue = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuQueueSetLabel(queue, label);
		break;
	}
	case 101: {
		WGPUQueue const queue = args[0].opaque_ptr;
		size_t const commandCount = args[1].u32;
		WGPUCommandBuffer const* const commands = args[2].buf.ptr;
		assert(args[2].buf.size == sizeof *commands);
		wgpuQueueSubmit(queue, commandCount, commands);
		break;
	}
	case 102: {
		WGPUQueue const queue = args[0].opaque_ptr;
		WGPUBuffer const buffer = args[1].opaque_ptr;
		uint64_t const bufferOffset = args[2].u64;
		void const* const data = args[3].opaque_ptr;
		size_t const size = args[4].u32;
		wgpuQueueWriteBuffer(queue, buffer, bufferOffset, data, size);
		break;
	}
	case 103: {
		WGPUQueue const queue = args[0].opaque_ptr;
		WGPUImageCopyTexture const* const destination = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *destination);
		void const* const data = args[2].opaque_ptr;
		size_t const dataSize = args[3].u32;
		WGPUTextureDataLayout const* const dataLayout = args[4].buf.ptr;
		assert(args[4].buf.size == sizeof *dataLayout);
		WGPUExtent3D const* const writeSize = args[5].buf.ptr;
		assert(args[5].buf.size == sizeof *writeSize);
		wgpuQueueWriteTexture(queue, destination, data, dataSize, dataLayout, writeSize);
		break;
	}
	case 104: {
		WGPUQueue const queue = args[0].opaque_ptr;
		wgpuQueueReference(queue);
		break;
	}
	case 105: {
		WGPUQueue const queue = args[0].opaque_ptr;
		wgpuQueueRelease(queue);
		break;
	}
	case 106: {
		WGPURenderBundle const renderBundle = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuRenderBundleSetLabel(renderBundle, label);
		break;
	}
	case 107: {
		WGPURenderBundle const renderBundle = args[0].opaque_ptr;
		wgpuRenderBundleReference(renderBundle);
		break;
	}
	case 108: {
		WGPURenderBundle const renderBundle = args[0].opaque_ptr;
		wgpuRenderBundleRelease(renderBundle);
		break;
	}
	case 109: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		uint32_t const vertexCount = args[1].u32;
		uint32_t const instanceCount = args[2].u32;
		uint32_t const firstVertex = args[3].u32;
		uint32_t const firstInstance = args[4].u32;
		wgpuRenderBundleEncoderDraw(renderBundleEncoder, vertexCount, instanceCount, firstVertex, firstInstance);
		break;
	}
	case 110: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		uint32_t const indexCount = args[1].u32;
		uint32_t const instanceCount = args[2].u32;
		uint32_t const firstIndex = args[3].u32;
		int32_t const baseVertex = args[4].i32;
		uint32_t const firstInstance = args[5].u32;
		wgpuRenderBundleEncoderDrawIndexed(renderBundleEncoder, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
		break;
	}
	case 111: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		WGPUBuffer const indirectBuffer = args[1].opaque_ptr;
		uint64_t const indirectOffset = args[2].u64;
		wgpuRenderBundleEncoderDrawIndexedIndirect(renderBundleEncoder, indirectBuffer, indirectOffset);
		break;
	}
	case 112: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		WGPUBuffer const indirectBuffer = args[1].opaque_ptr;
		uint64_t const indirectOffset = args[2].u64;
		wgpuRenderBundleEncoderDrawIndirect(renderBundleEncoder, indirectBuffer, indirectOffset);
		break;
	}
	case 113: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		WGPURenderBundleDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuRenderBundleEncoderFinish(renderBundleEncoder, descriptor);
		break;
	}
	case 114: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		char const* const markerLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *markerLabel);
		wgpuRenderBundleEncoderInsertDebugMarker(renderBundleEncoder, markerLabel);
		break;
	}
	case 115: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		wgpuRenderBundleEncoderPopDebugGroup(renderBundleEncoder);
		break;
	}
	case 116: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		char const* const groupLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *groupLabel);
		wgpuRenderBundleEncoderPushDebugGroup(renderBundleEncoder, groupLabel);
		break;
	}
	case 117: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		uint32_t const groupIndex = args[1].u32;
		WGPUBindGroup const group = args[2].opaque_ptr;
		size_t const dynamicOffsetCount = args[3].u32;
		uint32_t const* const dynamicOffsets = args[4].buf.ptr;
		assert(args[4].buf.size == sizeof *dynamicOffsets);
		wgpuRenderBundleEncoderSetBindGroup(renderBundleEncoder, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
		break;
	}
	case 118: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		WGPUBuffer const buffer = args[1].opaque_ptr;
		WGPUIndexFormat const format = args[2].u32;
		uint64_t const offset = args[3].u64;
		uint64_t const size = args[4].u64;
		wgpuRenderBundleEncoderSetIndexBuffer(renderBundleEncoder, buffer, format, offset, size);
		break;
	}
	case 119: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuRenderBundleEncoderSetLabel(renderBundleEncoder, label);
		break;
	}
	case 120: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		WGPURenderPipeline const pipeline = args[1].opaque_ptr;
		wgpuRenderBundleEncoderSetPipeline(renderBundleEncoder, pipeline);
		break;
	}
	case 121: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		uint32_t const slot = args[1].u32;
		WGPUBuffer const buffer = args[2].opaque_ptr;
		uint64_t const offset = args[3].u64;
		uint64_t const size = args[4].u64;
		wgpuRenderBundleEncoderSetVertexBuffer(renderBundleEncoder, slot, buffer, offset, size);
		break;
	}
	case 122: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		wgpuRenderBundleEncoderReference(renderBundleEncoder);
		break;
	}
	case 123: {
		WGPURenderBundleEncoder const renderBundleEncoder = args[0].opaque_ptr;
		wgpuRenderBundleEncoderRelease(renderBundleEncoder);
		break;
	}
	case 124: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const queryIndex = args[1].u32;
		wgpuRenderPassEncoderBeginOcclusionQuery(renderPassEncoder, queryIndex);
		break;
	}
	case 125: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const vertexCount = args[1].u32;
		uint32_t const instanceCount = args[2].u32;
		uint32_t const firstVertex = args[3].u32;
		uint32_t const firstInstance = args[4].u32;
		wgpuRenderPassEncoderDraw(renderPassEncoder, vertexCount, instanceCount, firstVertex, firstInstance);
		break;
	}
	case 126: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const indexCount = args[1].u32;
		uint32_t const instanceCount = args[2].u32;
		uint32_t const firstIndex = args[3].u32;
		int32_t const baseVertex = args[4].i32;
		uint32_t const firstInstance = args[5].u32;
		wgpuRenderPassEncoderDrawIndexed(renderPassEncoder, indexCount, instanceCount, firstIndex, baseVertex, firstInstance);
		break;
	}
	case 127: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		WGPUBuffer const indirectBuffer = args[1].opaque_ptr;
		uint64_t const indirectOffset = args[2].u64;
		wgpuRenderPassEncoderDrawIndexedIndirect(renderPassEncoder, indirectBuffer, indirectOffset);
		break;
	}
	case 128: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		WGPUBuffer const indirectBuffer = args[1].opaque_ptr;
		uint64_t const indirectOffset = args[2].u64;
		wgpuRenderPassEncoderDrawIndirect(renderPassEncoder, indirectBuffer, indirectOffset);
		break;
	}
	case 129: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		wgpuRenderPassEncoderEnd(renderPassEncoder);
		break;
	}
	case 130: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		wgpuRenderPassEncoderEndOcclusionQuery(renderPassEncoder);
		break;
	}
	case 131: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		size_t const bundleCount = args[1].u32;
		WGPURenderBundle const* const bundles = args[2].buf.ptr;
		assert(args[2].buf.size == sizeof *bundles);
		wgpuRenderPassEncoderExecuteBundles(renderPassEncoder, bundleCount, bundles);
		break;
	}
	case 132: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		char const* const markerLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *markerLabel);
		wgpuRenderPassEncoderInsertDebugMarker(renderPassEncoder, markerLabel);
		break;
	}
	case 133: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		wgpuRenderPassEncoderPopDebugGroup(renderPassEncoder);
		break;
	}
	case 134: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		char const* const groupLabel = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *groupLabel);
		wgpuRenderPassEncoderPushDebugGroup(renderPassEncoder, groupLabel);
		break;
	}
	case 135: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const groupIndex = args[1].u32;
		WGPUBindGroup const group = args[2].opaque_ptr;
		size_t const dynamicOffsetCount = args[3].u32;
		uint32_t const* const dynamicOffsets = args[4].buf.ptr;
		assert(args[4].buf.size == sizeof *dynamicOffsets);
		wgpuRenderPassEncoderSetBindGroup(renderPassEncoder, groupIndex, group, dynamicOffsetCount, dynamicOffsets);
		break;
	}
	case 136: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		WGPUColor const* const color = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *color);
		wgpuRenderPassEncoderSetBlendConstant(renderPassEncoder, color);
		break;
	}
	case 137: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		WGPUBuffer const buffer = args[1].opaque_ptr;
		WGPUIndexFormat const format = args[2].u32;
		uint64_t const offset = args[3].u64;
		uint64_t const size = args[4].u64;
		wgpuRenderPassEncoderSetIndexBuffer(renderPassEncoder, buffer, format, offset, size);
		break;
	}
	case 138: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuRenderPassEncoderSetLabel(renderPassEncoder, label);
		break;
	}
	case 139: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		WGPURenderPipeline const pipeline = args[1].opaque_ptr;
		wgpuRenderPassEncoderSetPipeline(renderPassEncoder, pipeline);
		break;
	}
	case 140: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const x = args[1].u32;
		uint32_t const y = args[2].u32;
		uint32_t const width = args[3].u32;
		uint32_t const height = args[4].u32;
		wgpuRenderPassEncoderSetScissorRect(renderPassEncoder, x, y, width, height);
		break;
	}
	case 141: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const reference = args[1].u32;
		wgpuRenderPassEncoderSetStencilReference(renderPassEncoder, reference);
		break;
	}
	case 142: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		uint32_t const slot = args[1].u32;
		WGPUBuffer const buffer = args[2].opaque_ptr;
		uint64_t const offset = args[3].u64;
		uint64_t const size = args[4].u64;
		wgpuRenderPassEncoderSetVertexBuffer(renderPassEncoder, slot, buffer, offset, size);
		break;
	}
	case 143: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		float const x = args[1].f32;
		float const y = args[2].f32;
		float const width = args[3].f32;
		float const height = args[4].f32;
		float const minDepth = args[5].f32;
		float const maxDepth = args[6].f32;
		wgpuRenderPassEncoderSetViewport(renderPassEncoder, x, y, width, height, minDepth, maxDepth);
		break;
	}
	case 144: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		wgpuRenderPassEncoderReference(renderPassEncoder);
		break;
	}
	case 145: {
		WGPURenderPassEncoder const renderPassEncoder = args[0].opaque_ptr;
		wgpuRenderPassEncoderRelease(renderPassEncoder);
		break;
	}
	case 146: {
		WGPURenderPipeline const renderPipeline = args[0].opaque_ptr;
		uint32_t const groupIndex = args[1].u32;
		notif.call_ret.ret.opaque_ptr = (void*) wgpuRenderPipelineGetBindGroupLayout(renderPipeline, groupIndex);
		break;
	}
	case 147: {
		WGPURenderPipeline const renderPipeline = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuRenderPipelineSetLabel(renderPipeline, label);
		break;
	}
	case 148: {
		WGPURenderPipeline const renderPipeline = args[0].opaque_ptr;
		wgpuRenderPipelineReference(renderPipeline);
		break;
	}
	case 149: {
		WGPURenderPipeline const renderPipeline = args[0].opaque_ptr;
		wgpuRenderPipelineRelease(renderPipeline);
		break;
	}
	case 150: {
		WGPUSampler const sampler = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuSamplerSetLabel(sampler, label);
		break;
	}
	case 151: {
		WGPUSampler const sampler = args[0].opaque_ptr;
		wgpuSamplerReference(sampler);
		break;
	}
	case 152: {
		WGPUSampler const sampler = args[0].opaque_ptr;
		wgpuSamplerRelease(sampler);
		break;
	}
	case 153: {
		WGPUShaderModule const shaderModule = args[0].opaque_ptr;
		WGPUShaderModuleGetCompilationInfoCallback const callback = args[1].opaque_ptr;
		void* const userdata = args[2].opaque_ptr;
		wgpuShaderModuleGetCompilationInfo(shaderModule, callback, userdata);
		break;
	}
	case 154: {
		WGPUShaderModule const shaderModule = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuShaderModuleSetLabel(shaderModule, label);
		break;
	}
	case 155: {
		WGPUShaderModule const shaderModule = args[0].opaque_ptr;
		wgpuShaderModuleReference(shaderModule);
		break;
	}
	case 156: {
		WGPUShaderModule const shaderModule = args[0].opaque_ptr;
		wgpuShaderModuleRelease(shaderModule);
		break;
	}
	case 157: {
		WGPUSurface const surface = args[0].opaque_ptr;
		WGPUSurfaceConfiguration const* const config = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *config);
		wgpuSurfaceConfigure(surface, config);
		break;
	}
	case 158: {
		WGPUSurface const surface = args[0].opaque_ptr;
		WGPUAdapter const adapter = args[1].opaque_ptr;
		WGPUSurfaceCapabilities* const capabilities = args[2].buf.ptr;
		assert(args[2].buf.size == sizeof *capabilities);
		wgpuSurfaceGetCapabilities(surface, adapter, capabilities);
		break;
	}
	case 159: {
		WGPUSurface const surface = args[0].opaque_ptr;
		WGPUSurfaceTexture* const surfaceTexture = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *surfaceTexture);
		wgpuSurfaceGetCurrentTexture(surface, surfaceTexture);
		break;
	}
	case 160: {
		WGPUSurface const surface = args[0].opaque_ptr;
		wgpuSurfacePresent(surface);
		break;
	}
	case 161: {
		WGPUSurface const surface = args[0].opaque_ptr;
		wgpuSurfaceUnconfigure(surface);
		break;
	}
	case 162: {
		WGPUSurface const surface = args[0].opaque_ptr;
		wgpuSurfaceReference(surface);
		break;
	}
	case 163: {
		WGPUSurface const surface = args[0].opaque_ptr;
		wgpuSurfaceRelease(surface);
		break;
	}
	case 164: {
		WGPUSurfaceCapabilities const surfaceCapabilities = *(WGPUSurfaceCapabilities*) args[0].opaque_ptr;
		wgpuSurfaceCapabilitiesFreeMembers(surfaceCapabilities);
		break;
	}
	case 165: {
		WGPUTexture const texture = args[0].opaque_ptr;
		WGPUTextureViewDescriptor const* const descriptor = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *descriptor);
		notif.call_ret.ret.opaque_ptr = (void*) wgpuTextureCreateView(texture, descriptor);
		break;
	}
	case 166: {
		WGPUTexture const texture = args[0].opaque_ptr;
		wgpuTextureDestroy(texture);
		break;
	}
	case 167: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetDepthOrArrayLayers(texture);
		break;
	}
	case 168: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetDimension(texture);
		break;
	}
	case 169: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetFormat(texture);
		break;
	}
	case 170: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetHeight(texture);
		break;
	}
	case 171: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetMipLevelCount(texture);
		break;
	}
	case 172: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetSampleCount(texture);
		break;
	}
	case 173: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetUsage(texture);
		break;
	}
	case 174: {
		WGPUTexture const texture = args[0].opaque_ptr;
		notif.call_ret.ret.u32 = wgpuTextureGetWidth(texture);
		break;
	}
	case 175: {
		WGPUTexture const texture = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuTextureSetLabel(texture, label);
		break;
	}
	case 176: {
		WGPUTexture const texture = args[0].opaque_ptr;
		wgpuTextureReference(texture);
		break;
	}
	case 177: {
		WGPUTexture const texture = args[0].opaque_ptr;
		wgpuTextureRelease(texture);
		break;
	}
	case 178: {
		WGPUTextureView const textureView = args[0].opaque_ptr;
		char const* const label = args[1].buf.ptr;
		assert(args[1].buf.size == sizeof *label);
		wgpuTextureViewSetLabel(textureView, label);
		break;
	}
	case 179: {
		WGPUTextureView const textureView = args[0].opaque_ptr;
		wgpuTextureViewReference(textureView);
		break;
	}
	case 180: {
		WGPUTextureView const textureView = args[0].opaque_ptr;
		wgpuTextureViewRelease(textureView);
		break;
	}
	// CALL_HANDLERS:END
	default:
		assert(false); // We should never receive a function ID that we don't know how to handle.
	}

	VDRIVER.notif_cb(&notif, VDRIVER.notif_data);
}

vdriver_t VDRIVER = {
	.spec = SPEC,
	.human = VDRIVER_HUMAN,
	.vers = VERS,
	.probe = probe,
	.conn = conn,
	.call = call,
};
