// This Source Form is subject to the terms of the AQUA Software License,
// v. 1.0. Copyright (c) 2025 Aymeric Wibo

#pragma once

#include <aqua/kos.h>

/**
 * Window driver "software" context.
 *
 * This is used by the window driver, and probably shouldn't be touched by the client.
 */
typedef struct win_softc_t* win_softc_t;

/**
 * Window object.
 *
 * This is an individual window created with `win_create`.
 */
typedef struct win_t* win_t;

/**
 * Initialize the window driver.
 *
 * This requests the window VDEV from the KOS. It should be called once at the beginning of the program to signal to the KOS that we want to request and receive attach notifications from window VDEVs.
 */
void win_init(void);

/**
 * Probe a VDEV to see if it's a window VDEV.
 *
 * This should be called by the client when it receives an attach notification from the KOS (`KOS_NOTIF_ATTACH`). `win_init` must be called first.
 *
 * @param vdev The VDEV to probe.
 * @return `true` if the VDEV is a window VDEV this driver supports, `false` if not.
 */
bool win_probe(kos_vdev_descr_t const* vdev);

/**
 * Connect to a window VDEV.
 *
 * Once we've chosen the attached window VDEV we'd like to connect to and we've called `win_probe` on it to ensure it is supported, this function may be called to create a driver context and connect to it.
 *
 * Since the caller probably wants to store the context before it gets a connection notification, this function doesn't flush the KOS. Instead, the caller must do this through `kos_flush(true)` after calling this function.
 *
 * `win_disconn` must be called to disconnect from the VDEV and to free the context.
 *
 * @param vdev The descriptor of the window VDEV to connect to.
 * @return The window driver context or `NULL` if allocation failed.
 */
win_softc_t win_conn(kos_vdev_descr_t const* vdev);

/**
 * Disconnect from a window VDEV.
 *
 * This function disconnects from the window VDEV and frees the context.
 *
 * @param sc The window driver context.
 */
void win_disconn(win_softc_t sc);

/**
 * Notify of a successful connection to a window VDEV.
 *
 * The client must call this function when receiving a connection success notification from the KOS (`KOS_NOTIF_CONN`). The driver will then ensure all the functions it needs are available on the VDEV and mark itself as ready to call functions on the VDEV if this connection notification is destined towards it.
 *
 * This function must be called for each `KOS_NOTIF_CONN` notification received; it will silently return early if the cookie doesn't match the one generated by the preceding `win_conn` call.
 *
 * @param sc The window driver context.
 * @param notif The connection notification.
 */
void win_notif_conn(win_softc_t sc, kos_notif_t const* notif);

/**
 * Notify of a call returning.
 *
 * The client must call this function when receiving a call return notification from the KOS (`KOS_NOTIF_CALL_RET`). The driver will then store the return value for later if this call return notification is destined towards it.
 *
 * This function must be called for each `KOS_NOTIF_CALL_RET` notification received; it will silently return early if the cookie doesn't match the one generated by the preceding call.
 *
 * @param sc The window driver context.
 * @param notif The call return notification.
 */
void win_notif_call_ret(win_softc_t sc, kos_notif_t const* notif);

/**
 * Create a window.
 *
 * Create a window object. This also registers an interrupt for window events. The caller must call `win_interrupt` on each `KOS_NOTIF_INTERRUPT` notification it receives for these window event interrupts to be processed.
 *
 * @param sc The window driver context.
 * @return A window object.
 */
win_t win_create(win_softc_t sc);

/**
 * Destroy a window.
 *
 * @param win The window to destroy.
 */
void win_destroy(win_t win);

/**
 * Enter the window event loop.
 *
 * This will block until the window is closed. Any registered callbacks will be called when the corresponding events they were registered for occur.
 *
 * @param win The window to start and enter the event loop of.
 */
void win_loop(win_t win);
