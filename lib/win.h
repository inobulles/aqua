// This Source Form is subject to the terms of the AQUA Software License,
// v. 1.0. Copyright (c) 2025 Aymeric Wibo

#pragma once

#include <aqua/kos.h>

// TODO Documentation.

/**
 * Opaque window handle.
 */
typedef void* win_t;

/**
 * Window driver "software" context.
 *
 * This is used by the window driver, and probably shouldn't be touched by the client.
 */
typedef struct {
	uint64_t hid;
	uint64_t vid;

	kos_cookie_t last_cookie;

	bool is_conn;
	uint64_t conn_id;

	struct {
		uint32_t create;
		uint32_t destroy;
		uint32_t loop;
	} fns;

	kos_val_t last_ret;
} win_softc_t;

/**
 * Initialize the window driver.
 *
 * This requests the window VDEV from the KOS. It should be called once at the beginning of the program to signal to the KOS that we want to request and receive attach notifications from window VDEVs.
 */
void win_init(void);

/**
 * Probe a VDEV to see if it's a window VDEV.
 *
 * This should be called by the client when it receives an attach notification from the KOS (`KOS_NOTIF_ATTACH`). `win_init` must be called first.
 *
 * @param vdev The VDEV to probe.
 * @return `true` if the VDEV is a window VDEV this driver supports, and `false` if not.
 */
bool win_probe(kos_vdev_descr_t const* vdev);

/**
 * Connect to a window VDEV.
 *
 * Once we've chosen the attached window VDEV we'd like to connect to and called `win_probe` on it to ensure it is supported, this function may be called to initialize a driver context and connect to it.
 *
 * @param sc The window driver context.
 * @param vdev The descriptor of the window VDEV to connect to.
 */
void win_conn(win_softc_t* sc, kos_vdev_descr_t const* vdev);

/**
 * Notify of a successful connection to a window VDEV.
 *
 * The client must call this function when receiving a connection success notification from the KOS (`KOS_NOTIF_CONN`). The driver will then ensure all the functions it needs are available on the VDEV and mark itself as ready to call functions on the VDEV if this connection notification is destined towards it.
 *
 * This function must be called for each `KOS_NOTIF_CONN` notification received; it will silently return if the cookie doesn't match the one generated by the preceding `win_conn` call.
 *
 * @param sc The window driver context.
 * @param notif The connection notification.
 */
void win_notif_conn(win_softc_t* sc, kos_notif_t const* notif);

/**
 * Notify of a call returning.
 *
 * The client must call this function when receiving a call return notification from the KOS (`KOS_NOTIF_CALL_RET`). The driver will then store the return value for later if this call return notification is destined towards it.
 *
 * This function must be called for each `KOS_NOTIF_CALL_RET` notification received; it will silently return if the cookie doesn't match the one generated by the preceding call.
 *
 * @param sc The window driver context.
 * @param notif The call return notification.
 */
void win_notif_call_ret(win_softc_t* sc, kos_notif_t const* notif);

/**
 * Create a window.
 *
 * @param sc The window driver context.
 * @return An opaque window handle.
 */
win_t win_create(win_softc_t* sc);

/**
 * Destroy a window.
 *
 * @param sc The window driver context.
 * @param win The window to destroy.
 */
void win_destroy(win_softc_t* sc, win_t win);

/**
 * Enter the window event loop.
 *
 * This will block until the window is closed. Any registered callbacks will be called when the corresponding events they were registered for occur.
 *
 * @param sc The window driver context.
 * @param win The window to enter the event loop for.
 */
void win_loop(win_softc_t* sc, win_t win);
